function returnSeed = UFlickerObj(varargin)
    % wrapper to call JitteringBackTex_UniformFieldObjText
    %
    % There are 4 different backgrounds. Each can be turned on/off by
    % setting clearing the corresponding bit in backMode array
    % backMode(1):    repeated random jitter, lasts backJitterPeriod
    %           all presentations have the same sequence
    % backMode(2):    random jitter, lasts backJitterPeriod
    %           every presentation has a different random sequence
    % backMode(3):    reversing @backReverseFreq
    % backMode(4):    still
    %
    % There are several obj rectangles (at least 1) passed through objRect
    % (an nx4 array describing the n rectangles).
    % Each rectangle can different contrasts passed through objContrasts,
    % an n x contrastN array. Each presentation will pick the contrasts 
    % randomly for each checker. Alternatively, objContrasts can be
    % 1xcontrastsN, in that case, each presentation picks the contrast
    % randomly but the same contrast is used for all checkers in that
    % presentation.
    %
    % Also, the random sequence in each checker can be repeated if
    % repeatObjSeq is set or they can all be different. Default behaviour
    % is, 'all presentations are different'.
    %
    % Internaly, I will work on backN 'presentations' at a time. I will
    % randomly pick an order for them and after displaying them all, I will
    % start again until presentationsN 'presentations' are done

    global vbl screen backRect backSource objRect pd

    if isempty(vbl)
        vbl=0;
    end
    
    p=ParseInput(varargin{:});

    objContrasts = p.Results.objContrast;
    objMeans = p.Results.objMean;
    objSeed  = p.Results.objSeed;
    objRect = p.Results.rects;

    
    backMode = logical(p.Results.backMode);             %[0 0 1 0] for reversing background.
    backContrast = p.Results.backContrast;
    backReverseFreq = p.Results.backReverseFreq;        % for reversing
    backJitterPeriod = p.Results.backJitterPeriod;
    backAngle = p.Results.angle;
    backSeed = p.Results.backSeed;
    backTex = p.Results.backTexture;
    backPattern = p.Results.backPattern;
    
    stimSize = p.Results.stimSize;
    presentationLength = p.Results.presentationLength;
    movieDurationSecs = p.Results.movieDurationSecs;
    debugging = p.Results.debugging;
    barsWidth = p.Results.barsWidth;
    waitframes = p.Results.waitframes;
    pdStim = p.Results.pdStim;
    
    backN = sum(backMode);
    contrastsN = size(objContrasts,2);

    
    % Redefine exp time to have an even number of jitters
    movieDurationSecs = contrastsN*backN*presentationLength* ...
        floor(movieDurationSecs/(contrastsN*backN*presentationLength));

    % if by any reason backJitterPeriod or objjitterPeriod are bigger than
    % presentationLength is because I forgot to input the right parameters,
    % fix it
    if (presentationLength < backJitterPeriod)
        backJitterPeriod = presentationLength;
    end
    if (size(objMeans,2) < size(objRect,1))
        objMeans = ones(1, size(objRect,1))*objMeans;
    end
    
try
    InitScreen(debugging);
    
    % make the background texture
    if (isempty(backTex))
        clearBackTexFlag = 1;
        if (backPattern)
            backTex = GetCheckersTex(stimSize+barsWidth, barsWidth, backContrast);
        else
            backTex = GetBarsTex(stimSize+barsWidth, barsWidth, backContrast);
        end
    else
        clearBackTexFlag = 0;
    end
    
    % Define the background Destination Rectangle
    backRect = SetRect(0,0,stimSize, stimSize);
    backRect = CenterRect(backRect, screen.rect);
    
    % Define the source rectangles
    backSource = SetRect(0, 0, stimSize, stimSize);
    backSourceOri = backSource;
    
    % Define the PD box
    if exist('pd', 'var')==0 || isempty(pd)
        pd = DefinePD();
    end

    framesPerSec = screen.rate;
    backJumpsPerPeriod = round(backJitterPeriod*framesPerSec);
    objJumpsPerPeriod = round(presentationLength*framesPerSec);

    % make the Still, the reversing and the random jitter background
    % the reverse (or saccading) experiment requires that the monitor freq
    % divided by the reversing freq to be an even number. Otherwise each
    % 'half period' will have different number of frames.
    if mod(scree.rate/backReverseFreq,2)
    jitterSeq(4,:)=zeros(1, backJumpsPerPeriod);
    forwardJumps = uint32(1:framesPerSec/backReverseFreq:backJumpsPerPeriod);
    backJumps = uint32(framesPerSec/backReverseFreq/2+1:framesPerSec/backReverseFreq:backJumpsPerPeriod);
    jitterSeq(3,forwardJumps)=   barsWidth;
    jitterSeq(3,backJumps)=   -barsWidth;
    S1 = RandStream('mcg16807', 'Seed', backSeed);
    jitterSeq(1,:)=randi(S1, 3, 1, backJumpsPerPeriod)-2;
    backStream = RandStream('mcg16807', 'Seed', backSeed);
    clear S1
    
    % We run at most 'presentationsN' if user doesn't abort via
    % keypress.
    presentationsN = uint32(movieDurationSecs/presentationLength)/backN;
    
    
    framesN = uint32(presentationLength*screen.rate);

    % make a random sequence of contrasts. If size(objContrasts,1)==1, then 
    % all checkers use the same contrast at any given point in time,
    % otherwise contrasts are randomly picked.
    S1 = RandStream('mcg16807', 'Seed',objSeed);
    contrastSeq = ones(1, presentationsN);
    blocksN = presentationsN/contrastsN;
    for i=0:blocksN-1
        contrastSeq(i*contrastsN+1:(i+1)*contrastsN) = randperm(S1, contrastsN);
    end
    clear S1;

    S = RandStream('mcg16807', 'Seed',objSeed);
    
    % for efficiency preallocate objSeq
    objSeq = ones(1, objJumpsPerPeriod);
    
    % Animationloop:
    for presentation = 1:presentationsN

        % get a random order of all possible backgrounds, even the ones
        % that are not displayed. Latter on we might skip some of them
        backOrder = randperm(backStream, 4);
%backOrder
%backOrderArray(presentation, :)=backOrder;
        for back=1:4
            if (back==1)
                contrastIndex = contrastSeq(presentation);
                contrast = objContrasts(contrastIndex);
                % Sets the objSeq that will be used in the next backN presentations
                %                   objSeq(checker,:) = uint8(randn(S{checker}, 1, objJumpsPerPeriod)*screen.gray*checkContrast+screen.gray);
                if (mod(presentation, contrastsN)==1 || contrastsN==1)
                    normDistribution = randn(S, 1, objJumpsPerPeriod);
                end
                
                % convert the normDistribution to intensity values taken
                % the contrast and mean into account.
                if (contrast==1)
                    objSeq = uint8(normDistribution>0)*255;
                else
                    objSeq = uint8(normDistribution*contrast*objMeans + objMeans);
                end
                
            end
            
            background = backMode(backOrder(back));
            % Do we have to skip this background?
            if (background==0)
                continue
            end
            if (backOrder(back)==2)
                % generate the new random jitter out of the backStream
                backSeq = randi(backStream, 3, 1, backJumpsPerPeriod)-2;
            else
                backSeq = jitterSeq(backOrder(back),:);
            end
            
            JitteringBackTex_UniformFieldObj(backSeq, objSeq, ...
                waitframes, framesN, backTex{1}, backAngle, barsWidth, pdStim)
            % Previous function DID modify backSource. Recenter it to prevent
            % too much sliding of the texture.
            % Is not perfect and sliding will still take place but will be
            % slower and hopefully will be ok
            backSource = mod(backSource, 2*barsWidth)+backSourceOri;
            
            if (KbCheck)
                break
            end
        end
        if (KbCheck)
            break
        end
    end
    
    if (clearBackTexFlag)
        % After drawing, we have to discard the noise checkTexture.
        Screen('Close', backTex{1});
    end
    
    returnSeed = S.State;
    
    FinishExperiment();
    
catch exception
    %this "catch" section executes in case of an error in the "try" section
    %above. Importantly, it closes the onscreen window if its open.
    CleanAfterError();
    psychrethrow(psychlasterror);
    rethrow(exception)
end %try..catch..
end

function p =  ParseInput(varargin)
    % Generates a structure with all the parameters
    % Allowed parameters are:
    %
    % objContrast, objSeed, stimSize, objSizeH, objSizeV,
    % objCenterXY, backContrast, backJitterPeriod, presentationLength,
    % movieDurationSecs, pdStim, debugging, barsWidth, waitframes, vbl

    % In order to get a parameter back just use
    %   p.Resulst.parameter
    % In order to display all the parameters use
    %   disp 'List of all arguments:'
    %   disp(p.Results)
    %
    % General format to add inputs is...
    % p.addRequired('script', @ischar);
    % p.addOptional('format', 'html', ...
    %     @(x)any(strcmpi(x,{'html','ppt','xml','latex'})));
    % p.addParamValue('outputDir', pwd, @ischar);
    % p.addParamValue('maxHeight', [], @(x)x>0 && mod(x,1)==0);

    p  = inputParser;   % Create an instance of the inputParser class.

    [screenX, screenY] = SCREEN_SIZE;
    rect =  CenterRectOnPoint([0 0 12 12]*PIXELS_PER_100_MICRONS, screenX/2, screenY/2);
    
    % Object related
    p.addParamValue('objSeed', 1, @(x) isnumeric(x));
    p.addParamValue('objContrast', [.03 .06 .12 .24 1], @(x) all(all(x>=0)) && all(all(x<=1)));
    p.addParamValue('objMean', 127, @(x) all(all(x>=0)) && all(all(x<=255)));
    p.addParamValue('rects', rect, @(x) size(x,1)==4 || size(x,2)==4);
    
    % Background related
    p.addParamValue('backSeed', 2, @(x)isnumeric(x));
    p.addParamValue('backMode', [0 0 1 0], @(x) size(x,1)==1 && size(x,2)==4);
    p.addParamValue('backContrast', 1, @(x)x>=0 && x<=1);
    p.addParamValue('backJitterPeriod', 2, @(x)x>0);
    p.addParamValue('backReverseFreq', 2, @(x) x>0);
    p.addParamValue('backTexture', [], @(x) iscell(x));
    p.addParamValue('backRect', GetRects(screenY, [screenX screenY]/2), @(x) isnumeric(x) && size(x,2)==4);
    p.addParamValue('backPattern', 1, @(x) x==0 || x==1);
    p.addParamValue('angle', 0, @(x) isnumeric(x));
    
    % General
    p.addParamValue('stimSize', PIXELS_PER_100_MICRONS*32, @(x)x>0);
    p.addParamValue('presentationLength', 100, @(x)x>0);
    p.addParamValue('movieDurationSecs', 10000, @(x)x>0);
    p.addParamValue('debugging', 0, @(x)x>=0 && x <=1);
    p.addParamValue('barsWidth', PIXELS_PER_100_MICRONS/2, @(x)x>0);
    p.addParamValue('waitframes', 1, @(x)isnumeric(x)); 
    p.addParamValue('pdStim', 3, @(x) isnumeric(x));
        

    % Call the parse method of the object to read and validate each argument in the schema:
    p.parse(varargin{:});
    
end

function JitteringBackTex_UniformFieldObj(jitterSeq, objSeq, ...
    waitframes, framesN, backTex, backAngle, barsWidth, pdStim)
    % Screen is divided in background and objects.
    % background will display the given texture at the given backAngle and will jitter it around
    % as specified by jitterSeq.
    % Objects will follow the intensities in objSeq
    % The time of the presentation comes in through framesN and if it is
    % longer than either jitterSeq or objSeq, then the jitter or the objSeq
    % sequences are repeated as many times as needed. In this way you can
    % have either:
    %   one background and one object
    %   one background with different objects
    %   different backgrounds with one object
    %
    % This procedure can also be used for reverse grating backgrounds, just
    % define the background to be the grating texture and define jitterSeq
    % to something like jitterSeq = [J 0 0 0 0 0 0 0 0 -J 0 0 0 0 0 0 0 0]
    % were the J is the size of the jump and the 0s are the frames where
    % the background is still
    % jitterSeq:    an array describing how many pixels to jump
    %               at each frame (+ to the right, - to the left)
    % objSeq:       the intensities to display in the Uniform Field obj
    % screen:       the usual screen struct.
    % waitFrames:   how often is the Flip going to be called?
    %               in general this will be either 1 or 2
    % framesN:      frames/screen.rate = totalLength of the presentation
    % backTex:      the texture to show in the background.
    % backRect:     where to display the background
    % backSource:   what part of the texture to display
    % objRect:      where to display the object
    % vbl:          time of last flip call
    % pd:           PD box definition

    global vbl screen backRect backSource objRect pd
    
    recenterFlag=1;

    backSize = backSource(4)-backSource(2);
    y1ori = backSource(2);
    x1 = mod(backSource(1), 2*barsWidth);
%    x1 = x1ori;
    
    jumpsN = size(jitterSeq,2);
    objSeqN = size(objSeq, 2);
    
    for frame=0:framesN-1
        if (mod(frame, waitframes)==0)
%            backIndex = mod(frame/waitframes, jumpsN)+1;
            backIndex = mod(frame, jumpsN)+1;
            x1 = x1 + jitterSeq(backIndex);
            if (recenterFlag)
                x1 = mod(x1, 2*barsWidth);
            end
            backSource = x1*[1 0 1 0] + y1ori*[0 1 0 1] + backSize*[0 0 1 1];
            Screen('FillRect', screen.w, screen.gray, screen.rect);

            % Disable alpha-blending, restrict following drawing to alpha channel:
            Screen('Blendfunction', screen.w, GL_ONE, GL_ZERO, [0 0 0 1]);

            % Clear 'dstRect' region of framebuffers alpha channel to zero:
    %        Screen('FillRect', screen.w, [0 0 0 0], backRect);
            Screen('FillRect', screen.w, [0 0 0 0], screen.rect);

            % Fill circular 'dstRect' region with an alpha value of 255:
            Screen('FillOval', screen.w, [0 0 0 255], backRect);

            % Enable DeSTination alpha blending and reenalbe drawing to all
            % color channels. Following drawing commands will only draw there
            % the alpha value in the framebuffer is greater than zero, ie., in
            % our case, inside the circular 'dst2Rect' aperture where alpha has
            % been set to 255 by our 'FillOval' command:
            Screen('Blendfunction', screen.w, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, [1 1 1 1]);

            % Draw 2nd grating texture, but only inside alpha == 255 circular
            % aperture, and at an angle of 90 degrees:
            Screen('DrawTexture', screen.w, backTex, backSource, backRect, backAngle,0)

            % Restore alpha blending mode for next draw iteration:
            Screen('Blendfunction', screen.w, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


            % Object Drawing
            % --------------
            for i=1:size(objRect,1)
                objIndex = mod(frame/waitframes, objSeqN)+1;
                objColor = objSeq(i, objIndex);
                Screen('FillRect', screen.w, objColor, objRect(i,:));
            end
        end

        % Photodiode box
        % --------------
        DisplayStimInPD2(pdStim, pd, frame, screen.rate, screen)

        % Flip 'waitframes' monitor refresh intervals after last redraw.
        vbl = Screen('Flip', screen.w, vbl + 0.5 * screen.ifi, 1);

        if KbCheck
            break
        end
    end
end




