function test6()
% Parameters
lineWidth = 10;
squareSize = 100;
rectSize = 700;
seed = 1;
waitframes = 1;

movieDurationSecs=20; % Abort demo after 20 seconds.

try
    AssertOpenGL;

    % Get the list of screens and choose the one with the highest screen number.
    screenNumber=max(Screen('Screens'));

    % Find the color values which correspond to white and black.
    white=WhiteIndex(screenNumber);
    black=BlackIndex(screenNumber);

    % Round gray to integral number, to avoid roundoff artifacts with some
    % graphics cards:
	gray=round((white+black)/2);

    % This makes sure that on floating point framebuffers we still get a
    % well defined gray. It isn't strictly neccessary in this demo:
    if gray == white
		gray=white / 2;
    end

    % Open a double buffered fullscreen window with a gray background:
    if (screenNumber == 0)
        [w screenRect]=Screen('OpenWindow',screenNumber, gray);
%        [w screenRect]=Screen('OpenWindow',screenNumber, gray, [0 0 400 400]);
    else
        [w screenRect]=Screen('OpenWindow',screenNumber, gray);
    end
    
    % Create one single static grating image:
    % MK: We only need a single texture row (i.e. 1 pixel in height) to
    % define the whole grating! If srcRect in the Drawtexture call below is
    % "higher" than that (i.e. visibleSize >> 1), the GPU will
    % automatically replicate pixel rows. This 1 pixel height saves memory
    % and memory bandwith, ie. potentially faster.
    [x,y]=meshgrid(1:rectSize, 1);
    grating=mod(floor(x/lineWidth), 2)*white;


    % Store grating in texture:
    gratingtex=Screen('MakeTexture', w, grating);

    % Create a single gaussian transparency mask and store it to a texture:
    mask    = ones(rectSize, rectSize, 2) * gray;
    [x,y]   = meshgrid(1:rectSize, 1:rectSize);
    maskX   = mod(floor(x/squareSize), 2);
    maskY   = mod(floor(y/squareSize), 2);
    maskZ   = white * ((maskX .* maskY) + (1-maskX) .* (1-maskY));
    mask(:, :, 2)=maskZ(:,:);
    masktex=Screen('MakeTexture', w, mask);
    clear x y mask maskX maskY %maskZ
    
    % Definition of the drawn rectangle on the screen:
    dstRect=SetRect(0,0, rectSize, rectSize);
    dstRect=CenterRect(dstRect, screenRect);

    % Definition of the rectangle who's border will be drawn to mask the
    % rotated textures.
    penWidth=150;
    frameRect = SetRect(0,0,rectSize+2*penWidth, rectSize+2*penWidth);
    frameRect = CenterRect(frameRect, screenRect);

    % Query duration of monitor refresh interval:
    ifi=Screen('GetFlipInterval', w);

    rand('seed', seed);
    
    % Perform initial Flip to sync us to the VBL and for getting an initial
    % VBL-Timestamp for our "WaitBlanking" emulation:
    vbl=Screen('Flip', w);

    % We run at most 'movieDurationSecs' seconds if user doesn't abort via
    % keypress.
    vblendtime = vbl + movieDurationSecs;
    frame = 0
    
    % Animationloop:
    while (vbl < vblendtime) & ~KbCheck %#ok<AND2>

        % Shift the grating by "shiftperframe" pixels per frame:
        sec = floor(frame/60);
        stim = mod(sec, 10);
        angle1=rand()*360;
        switch stim
            case 0
                angle2=angle1;
            otherwise
                angle2=rand()*360;
        end

        % Draw grating texture, rotated by "angle":
        Screen('DrawTexture', w, gratingtex, [], dstRect, angle1, 0, 1);

        % Disable alpha-blending, restrict following drawing to alpha channel:
        Screen('Blendfunction', w, GL_ONE, GL_ZERO, [0 0 0 1]);
        
        % Clear 'dstRect' region of framebuffers alpha channel to zero:
        Screen('FillRect', w, [0 0 0 0], dstRect);
        
        % Fill circular 'dstRect' region with an alpha value of 255:
        Screen('DrawTexture', w, masktex, [], dstRect, 0, 0, [], [0 0 0 255]);
        
        % Enable DeSTination alpha blending and reenalbe drawing to all
        % color channels. Following drawing commands will only draw there
        % the alpha value in the framebuffer is greater than zero, ie., in
        % our case, inside the circular 'dst2Rect' aperture where alpha has
        % been set to 255 by our 'FillOval' command:
        Screen('Blendfunction', w, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, [1 1 1 1]);
        
        % Draw 2nd grating texture, but only inside alpha == 255 circular
        % aperture, and at an angle of 90 degrees:
        Screen('DrawTexture', w, gratingtex, [], dstRect, angle2);
        
        % Restore alpha blending mode for next draw iteration:
        Screen('Blendfunction', w, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        Screen('FrameOval', w, gray, frameRect, penWidth);
        
        % Flip 'waitframes' monitor refresh intervals after last redraw.
        vbl = Screen('Flip', w, vbl + (waitframes - 0.5) * ifi);
        frame = frame + 1;
    end;

    Priority(0);
    Screen('CloseAll');

catch
    %this "catch" section executes in case of an error in the "try" section
    %above. Importantly, it closes the onscreen window if its open.
    clear Screen
    Screen('CloseAll');
    Priority(0);
    psychrethrow(psychlasterror);
end %try..catch..
